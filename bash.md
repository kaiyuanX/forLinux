- [拓展](#拓展)
    - [拓展的两种模式](#拓展的两种模式)
- [转义](#转义)
- [引号](#引号)
    - [单引号](#单引号)
    - [双引号](#双引号)
- [变量](#变量)
- [字符串操作](#字符串操作)
    - [字符串长度](#字符串长度)
    - [子字符串](#子字符串)
    - [搜索和替换](#搜索和替换)
    - [改变大小写](#改变大小写)
- [算术运算](#算术运算)
    - [算术表达式](#算术表达式)
    - [数值的进制](#数值的进制)
    - [expr 命令](#expr-命令)
    - [let 命令](#let-命令)
- [行操作（快捷键的使用）](#行操作快捷键的使用)
    - [~~光标移动~~](#光标移动)
    - [~~编辑操作~~](#编辑操作)
    - [自动补全](#自动补全)
    - [操作历史](#操作历史)
    - [~~其他快捷键~~](#其他快捷键)
- [目录堆栈](#目录堆栈)
    - [cd -](#cd--)
    - [pushd，popd](#pushdpopd)
    - [dirs](#dirs)
- [Bash 脚本入门](#bash-脚本入门)
    - [Shebang 行](#shebang-行)
    - [执行权限和路径](#执行权限和路径)
    - [env 命令](#env-命令)
    - [注释](#注释)
    - [脚本参数](#脚本参数)
    - [shift 命令](#shift-命令)
    - [getopts 命令](#getopts-命令)
    - [配置项参数终止符 `--`](#配置项参数终止符---)
    - [exit 命令](#exit-命令)
    - [命令执行结果](#命令执行结果)
    - [source 命令](#source-命令)
    - [别名，alias 命令](#别名alias-命令)

参考

- [Bash 脚本教程](https://www.ruanyifeng.com/blog/2020/04/bash-tutorial.html)

包含 shell 等词汇的解释（在第一部分）

本文的二级标题与参考文档的目录一一对应

## 拓展

Bash 提供 8 种 拓展 ( globbing )

- `~` 扩展
- `?` 字符扩展
- `*` 字符扩展
- `[]` 扩展
- `{}` 扩展
- 变量扩展
  - `${!sth*}` 扩展成所有以 sth 开头的变量名
- 子命令扩展
  - `$(..)` 可以扩展成另一个命令的运行结果，该命令的所有输出都会作为返回值
- 算术扩展
  - `$((..))` 可以扩展成整数运算的结果，详见《Bash 的算术运算》一章

文件名包括特殊字符时（如 `*`），引用文件名，需要把文件名放在单引号或双引号里面

```bash
$ touch 'fo*'  # 创建名字为 fo* 的文件
```

> Shell 接收到用户输入的命令后，会根据空格将用户的输入拆分成一个个词元（token）  
> 
> Shell 先会扩展词元里面的特殊字符，扩展完成后才会调用相应的命令

#### 拓展的两种模式

- 总是拓展
- 匹配失败，原样输出

目录下没有 `a.txt b.txt`

![](image/2023-06-27-17-39-27.png)

## 转义

> Bash 只有一种数据类型，就是字符串

某些字符在 Bash 里面有特殊含义（比如 `$ & *`）

如果想要原样输出这些特殊字符，就必须在它们前面加上反斜杠，使其变成普通字符

这就叫做 “转义”（escape）

反斜杠除了用于转义，还可以表示一些不可打印的字符

- `\a`：响铃
- `\b`：退格
- `\n`：换行
- `\r`：回车
- `\t`：制表符

```bash
# \ 的另一个用法

$ mv \
/path/to/foo \
/path/to/bar

# 等同于
$ mv /path/to/foo /path/to/bar
```

## 引号

#### 单引号

单引号用于保留字符的字面含义，==各种特殊字符==在单引号里面，都会变为普通字符

打印单引号的方法

```
$ echo "it's"
it's
```

#### 双引号

双引号比单引号宽松，==大部分特殊字符==在双引号里面，会失去特殊含义，变成普通字符

`` $ `` `` ` ``  `` \ `` 这三个仍然有特殊函数

用法
- 使用反斜杠，在双引号之中插入双引号，或者插入反斜杠
- `$ ls "two words.txt"` 引用有空格的文件名
- `$ echo "this is a     test"` 保留多个空格
- 保存原始命令的输出格式

```bash
# 单行输出
$ echo $(cal)
一月 2020 日 一 二 三 四 五 六 1 2 3 ... 31

# 原始格式输出
$ echo "$(cal)"
      一月 2020
日 一 二 三 四 五 六
          1  2  3  4
 5  6  7  8  9 10 11
12 13 14 15 16 17 18
19 20 21 22 23 24 25
26 27 28 29 30 31
```

## 变量

> Bash 变量分成环境变量和自定义变量两类

- 常见的**环境变量**
- 自定义变量
  - 创建
  - 读取
  - 删除：`unset SOME`
  - 输出：`export SOME='sth'` 
    - 当前 Shell 及随后新建的子 Shell，都可以读取变量 `$SOME`
    - 子 Shell 如果修改继承的变量，不会影响父 Shell  
- 特殊变量
  - 这些变量的值由 Shell 提供，用户不能进行赋值，详见[参考文档：变量]()一节
- 对变量的其他操作
  - 变量的默认值 `${SOME op return}`
  - `declare`
  - `readonly`
  - `let`

## 字符串操作

#### 字符串长度

获取字符串长度的语法 `${#varname}`

#### 子字符串

字符串提取子串的语法

```
$ varname=frogmanfoot
$ echo ${varname:4:3}
man
```

#### 搜索和替换

- 字符串**头部**的模式匹配

```bash
# 原始变量不会发生变化

# 如果 pattern 匹配变量 variable 的开头，
# 删除最短匹配（非贪婪匹配）的部分，返回剩余部分
${variable#pattern}

# 如果 pattern 匹配变量 variable 的开头，
# 删除最长匹配（贪婪匹配）的部分，返回剩余部分
${variable##pattern}

# 将头部匹配的部分，替换成其他内容
# 模式必须出现在字符串的开头
${variable/#pattern/string}
```

- 字符串**尾部**的模式匹配

```bash
# 对称于上面的用法
${variable%pattern}

${variable%%pattern}

${variable/%pattern/string}
```

- 任意位置的模式匹配

```bash
# 最长匹配的那部分被 string 替换，但仅替换第一个匹配
${variable/pattern/string}

# 最长匹配的那部分被 string 替换，所有匹配都替换
${variable//pattern/string}

# 模式部分可以使用通配符
```

#### 改变大小写

```bash
# 转为大写
${varname^^}

# 转为小写
${varname,,}
```

## 算术运算

#### 算术表达式

`((...))`

如果要读取结果，前面加上美元符号 `$`

支持的操作符

- 算术运算
- 位运算
- 逻辑运算
- 赋值运算
  - `$((a=1))`
  - 上面例子中，`a=1` 对变量 a 进行赋值
  - 这个式子本身也是一个表达式，返回值就是等号右边的值

#### 数值的进制

- `number`：没有任何特殊表示法的数字是十进制数
- `0number`：八进制数
- `0xnumber`：十六进制数
- `base#number`：base 进制的数

#### expr 命令

`expr` 命令支持**算术运算**

#### let 命令

`let` 命令用于将**算术运算**的结果，赋予一个变量

## 行操作（快捷键的使用）

Bash 内置了 Readline 库，具有这个库提供的很多 “行操作” 功能

- 默认采用 Emacs 快捷键，下文都是 Emacs 风格的快捷键
- 还支持 Vim 风格

```bash
$ set -o vi     # 改成 Vi 快捷键
```

可以在主目录中的 `~/.bashrc` 文件底部添加下面的行来持久设置它 `set -o vi`

#### ~~光标移动~~
- `Ctrl + b`：向行首移动一个字符，与左箭头作用相同
- `Ctrl + f`：向行尾移动一个字符，与右箭头作用相同
- `Alt + b`：移动到当前单词的词首
- `Alt + f`：移动到当前单词的词尾
- `Ctrl + a`：移到行首
- `Ctrl + e`：移到行尾

上面快捷键的 Alt 键，也可以用 ESC 键代替

#### ~~编辑操作~~

下面的快捷键可以编辑命令行内容。

- `Ctrl + d`：删除光标位置的字符（delete）
- `Ctrl + w`：删除光标前面的单词
- `Alt + l`：将光标位置至词尾转为小写（lowercase）
- `Alt + u`：将光标位置至词尾转为大写（uppercase）

使用 `Ctrl + d` 的时候，如果当前行没有任何字符，会导致退出当前 Shell

剪切和粘贴快捷键如下

- `Ctrl + u`：剪切光标位置到行首的文本
- `Ctrl + k`：剪切光标位置到行尾的文本
- `Alt + d`：剪切光标位置到词尾的文本
- `Alt + Backspace`：剪切光标位置到词首的文本
- `Ctrl + y`：在光标位置粘贴文本

Alt 键可以用 Esc 键代替

#### 自动补全

命令输入到一半的时候，可以按一下 Tab 键，Readline 会自动补全==命令或路径==

- 比如，输入 cle ，再按下 Tab 键，Bash 会自动将这个命令补全为 clear

如果符合条件的命令或路径有多个，就需要连续按两次 Tab 键，Bash 会提示所有符合条件的命令或路径

一些快捷键见[参考文档]()

#### 操作历史

```bash
$ echo $HISTFILE
/home/me/.bash_history
```

`history`
- 退出当前 Shell 的时候，Bash 会将用户在当前 Shell 的操作历史写入 `~/.bash_history` 文件，该文件默认储存 500 个操作
- 环境变量 `HISTFILE` 总是指向这个文件
- 更多 `history` 的配置见[参考文档]()

`!sth`
- 只会匹配命令，不会匹配参数
- 打印 `!` 记得转义
- 开启选项 `histverify`，`!` 的拓展会先打印出来，等到用户按下回车键后再执行
- `!!`：执行上一个命令
- `!number`：历史文件里面行号为 number 的命令
- `!string`：执行最近一个以指定字符串 string 开头的命令
- `!?string`：执行最近一条包含字符串 string 的命令

`^r`

#### ~~其他快捷键~~

- `Ctrl + j`：等同于回车键（LINEFEED）
- `Ctrl + m`：等同于回车键（CARRIAGE RETURN）
- `Ctrl + [`：等同于 ESC

## 目录堆栈

方便用户在不同目录之间切换

#### cd -

#### pushd，popd

```bash
# 当前处在主目录，堆栈为空
$ pwd
/home/me

# 进入 /home/me/foo
# 当前堆栈为 /home/me
$ pushd ~/foo

# 进入 /etc
# 当前堆栈为 /home/me/foo /home/me
$ pushd /etc

# 进入 /home/me/foo
# 当前堆栈为 /home/me
$ popd

# 进入 /home/me
# 当前堆栈为
$ popd

# 目录不变，当前堆栈为空
$ popd
```

#### dirs

显示目录堆栈的内容，目录之间使用空格分隔

第一个为当前所在位置，第二个是栈顶，以此类推

`-c`：清空目录栈


## Bash 脚本入门

#### Shebang 行

脚本的第一行通常是指定解释器

这一行以 `#!` 字符开头，这个字符称为 Shebang，所以这一行就叫做 Shebang 行

`#!` 后面就是脚本解释器的位置，Bash 脚本的解释器一般是 `/bin/sh` 或 `/bin/bash`

`#!` 与脚本解释器之间有没有空格，都是可以的

```c
#!/bin/sh
# 或者
#!/bin/bash
```


如果 Bash 解释器不放在目录 `/bin`，脚本就无法执行了。为了保险，可以写成下面这样

```
#!/usr/bin/env bash
```

上面命令使用 `env` 命令（这个命令总是在`/usr/bin`目录），返回 Bash 可执行文件的位置

`env` 命令的详细介绍，请看后文

Shebang 行不是必需的，但是建议加上这行。如果缺少该行，就需要手动将脚本传给解释器

举例来说，脚本是 `script.sh`，有 Shebang 行的时候，可以直接调用执行

```
$ ./script.sh
```

上面例子中，`script.sh` 是脚本文件名。脚本通常使用`.sh`后缀名，不过这不是必需的

如果没有 Shebang 行，就只能手动将脚本传给解释器来执行

```
$ /bin/sh ./script.sh
# 或者
$ bash ./script.sh
```

#### 执行权限和路径 

前面说过，只要指定了 Shebang 行的脚本，可以直接执行。这有一个前提条件，就是脚本需要有执行权限。可以使用下面的命令，赋予脚本执行权限。

```bash
# 给所有用户执行权限
$ chmod +x script.sh

# 给所有用户读权限和执行权限
$ chmod +rx script.sh
# 或者
$ chmod 755 script.sh

# 只给脚本拥有者读权限和执行权限
$ chmod u+rx script.sh
```

脚本的权限通常设为`755`
- 拥有者有所有权限，其他人有读和执行权限

或者 `700`
- 只有拥有者可以执行

除了执行权限，脚本调用时，一般需要指定脚本的路径（比如`path/script.sh`）。如果将脚本放在环境变量`$PATH`指定的目录中，就不需要指定路径了。因为 Bash 会自动到这些目录中，寻找是否存在同名的可执行文件。

建议在主目录新建一个 `~/bin` 子目录，专门存放可执行脚本，然后把 `~/bin` 加入 `$PATH`

```
export PATH=$PATH:~/bin
```

上面命令改变环境变量 `$PATH`，将 `~/bin` 添加到 `$PATH` 的末尾

可以将这一行加到 `~/.bashrc` 文件里面，然后重新加载一次`.bashrc`，这个配置就可以生效了

```
$ source ~/.bashrc
```

以后不管在什么目录，直接输入脚本文件名，脚本就会执行

#### env 命令

`env` 这个二进制文件总是在目录 `/usr/bin`

`#!/usr/bin/env NAME` 这个语法的意思是，让 Shell 查找 `$PATH` 环境变量里面第一个匹配的 `NAME`

如果你不知道某个命令的具体路径，或者希望兼容其他用户的机器，这样的写法就很有用

`/usr/bin/env bash`的意思就是，返回 `bash` 可执行文件的位置，前提是 `bash` 的路径是在 `$PATH` 里面

其他脚本文件也可以使用这个命令。比如 Node.js 脚本的 Shebang 行，可以写成下面这样

```
#!/usr/bin/env node
```

`env` 命令的参数如下

*   `-i`, `--ignore-environment`：不带环境变量启动
*   `-u`, `--unset=NAME`：从环境变量中删除一个变量
*   `--help`：显示帮助
*   `--version`：输出版本信息

下面是一个例子，新建一个不带任何环境变量的 Shell

```
$ env -i /bin/sh
```

#### 注释

Bash 脚本中，`#` 表示注释

建议在脚本开头，使用注释说明当前脚本的作用，这样有利于日后的维护

#### 脚本参数

调用脚本的时候，脚本文件名后面可以带有参数

```
$ script.sh word1 word2 word3    # script.sh 是一个脚本文件，word1、word2 和 word3 是三个参数
```

脚本文件内部，可以使用特殊变量，引用这些参数

*   `$0`：脚本文件名，即 `script.sh`
*   `$1`~`$9`：对应脚本的第一个参数到第九个参数
*   `$#`：参数的总数
*   `$@`：全部的参数，参数之间使用空格分隔
*   `$*`：全部的参数，参数之间使用变量 `$IFS` 值的第一个字符分隔，默认为空格，但是可以自定义

如果脚本的参数多于 9 个，那么第 10 个参数可以用`${10}`的形式引用，以此类推

注意，如果命令是 `command -o foo bar`，那么 `-o` 是 `$1` ，`foo` 是 `$2`，`bar` 是 `$3`

下面是一个脚本内部读取命令行参数的例子

```
#!/bin/bash

for i in "$@"; do
  echo $i
done
```

#### shift 命令

`shift` 命令可以改变脚本参数，每次执行都会移除脚本当前的第一个参数（`$1`），使得后面的参数向前一位，即`$2`变成`$1`、`$3`变成`$2`、`$4`变成`$3`，以此类推

`while`循环结合`shift`命令，也可以读取每一个参数

```
#!/bin/bash

echo "一共输入了 $# 个参数"

while [ "$1" != "" ]; do
  echo "剩下 $# 个参数"
  echo "参数：$1"
  shift
done

```

上面例子中，`shift` 命令每次移除当前第一个参数，从而通过 `while` 循环遍历所有参数

`shift` 命令可以接受一个整数作为参数，指定所要移除的参数个数，默认为 `1`

```
shift 3
```

上面的命令移除前三个参数，原来的 `$4` 变成 `$1`

#### getopts 命令

`getopts` 命令用在脚本内部，可以解析复杂的脚本命令行参数，通常与 `while` 循环一起使用，取出脚本所有的带有前置连词线（`-`）的参数

```
getopts optstring name
```

它带有两个参数
- 第一个参数 `optstring` 是字符串，给出脚本所有的连词线参数
  - 比如，某个脚本可以有三个配置项参数 `-l`、`-h`、`-a`，其中只有 `-a` 可以带有参数值，而`-l`和`-h`是开关参数，那么 `getopts` 的第一个参数写成 `lha:`，顺序不重要
  - 注意，`a` 后面有一个冒号，表示该参数带有参数值
  - `getopts` 规定带有参数值的配置项参数，后面必须带有一个冒号（`:`）
- 第二个参数 `name` 是一个变量名，用来保存当前取到的配置项参数，即 `l` `h` `a`

下面是一个例子

```BASH
while getopts 'lha:' OPTION; do
  case "$OPTION" in
    l)
      echo "linuxconfig"
      ;;

    h)
      echo "h stands for h"
      ;;

    a)
      avalue="$OPTARG"
      echo "The value provided is $OPTARG"
      ;;
    ?)
      echo "script usage: $(basename $0) [-l] [-h] [-a somevalue]" >&2
      exit 1
      ;;
  esac
done
shift "$(($OPTIND - 1))"
```

上面例子中，`while`循环不断执行`getopts 'lha:' OPTION`命令，每次执行就会读取一个连词线参数（以及对应的参数值），然后进入循环体。变量`OPTION`保存的是，当前处理的那一个连词线参数（即`l`、`h`或`a`）。如果用户输入了没有指定的参数（比如`-x`），那么`OPTION`等于`?`。循环体内使用`case`判断，处理这四种不同的情况。

如果某个连词线参数带有参数值，比如`-a foo`，那么处理`a`参数的时候，环境变量`$OPTARG`保存的就是参数值。

注意，只要遇到不带连词线的参数，`getopts`就会执行失败，从而退出`while`循环。比如，`getopts`可以解析`command -l foo`，但不可以解析`command foo -l`。另外，多个连词线参数写在一起的形式，比如`command -lh`，`getopts`也可以正确处理。

变量`$OPTIND`在`getopts`开始执行前是`1`，然后每次执行就会加`1`。等到退出`while`循环，就意味着连词线参数全部处理完毕。这时，`$OPTIND - 1`就是已经处理的连词线参数个数，使用`shift`命令将这些参数移除，保证后面的代码可以用`$1`、`$2`等处理命令的主参数。

#### 配置项参数终止符 `--`

`-` 和 `--` 开头的参数，会被 Bash 当作配置项解释。但是，有时它们不是配置项，而是实体参数的一部分，比如文件名叫做 `-f` 或 `--file`

```
$ cat -f
$ cat --file

```

上面命令的原意是输出文件 `-f` 和 `--file` 的内容，但是会被 Bash 当作配置项解释

这时就可以使用配置项参数终止符`--`，它的作用是告诉 Bash，在它后面的参数开头的`-`和`--`不是配置项，只能当作实体参数解释

```
$ cat -- -f
$ cat -- --file
```

如果要确保某个变量不会被当作配置项解释，就要在它前面放上参数终止符 `--`

```
$ ls -- $myPath

```


另一个例子，如果想在文件里面搜索 `--hello`，这时也要使用参数终止符 `--`

```
$ grep -- "--hello" example.txt
```

#### exit 命令

`exit` 命令用于终止当前脚本的执行，并向 Shell 返回一个退出值

```
$ exit
```

上面命令中止当前脚本，将最后一条命令的退出状态，作为整个脚本的退出状态

`exit` 命令后面可以跟参数，该参数就是退出状态

```
# 退出值为 0（成功）
$ exit 0

# 退出值为 1（失败）
$ exit 1
```

退出时，脚本会返回一个退出值
- `0` 表示正常
- `1` 表示发生错误
- `2` 表示用法不对
- `126` 表示不是可执行脚本
- `127` 表示命令没有发现
- 如果脚本被信号 `N` 终止，则退出值为`128 + N`。

简单来说，只要退出值非 0，就认为执行出错

下面是一个例子

```
if [ $(id -u) != "0" ]; then
  echo "根用户才能执行当前脚本"
  exit 1
fi
```

`id -u` 命令返回用户的 ID，一旦用户的 ID 不等于 `0`（根用户的 ID），脚本就会退出，退出码为 `1`

`exit` 与 `return` 命令的差别是
- `return` 命令是函数的退出，并返回一个值给调用者，脚本依然执行
- `exit` 是整个脚本的退出，如果在函数之中调用`exit`，则退出函数，并终止脚本执行

#### 命令执行结果

命令执行结束后，会有一个返回值

环境变量 `$?` 可以读取前一个命令的返回值

利用这一点，可以在脚本中对命令执行结果进行判断

```
cd /path/to/somewhere
if [ "$?" = "0" ]; then
  rm *
else
  echo "Could not change directory! Aborting." 1>&2
  exit 1
fi

```

上面例子中，`cd /path/to/somewhere` 这个命令如果执行成功就删除该目录里面的文件，否则退出脚本，整个脚本的返回值变为 `1`，表示执行失败

`if` 可以直接判断命令的执行结果，上面的脚本等价下面的样子

```
if cd /path/to/somewhere; then
  rm *
else
  echo "Could not change directory! Aborting." 1>&2
  exit 1
fi
```

更简洁的写法是利用两个逻辑运算符 `&&` 和 `||`

```
# 第一步执行成功，才会执行第二步
cd /path/to/somewhere && rm *

# 第一步执行失败，才会执行第二步
cd /path/to/somewhere || exit 1
```

#### source 命令

`source` 命令用于执行一个脚本，通常用于重新加载一个配置文件

```bash
$ source .bashrc
```

`source` 命令最大的特点是在当前 Shell 执行脚本，不像直接执行脚本时，会新建一个子 Shell

所以，`source`命令执行脚本时，不需要`export`变量

```bash
#!/bin/bash
# test.sh
echo $foo
```

```bash
# 当前 Shell 新建一个变量 foo
$ foo=1

# 输出 1
$ source test.sh
1

# 输出空
$ bash test.sh
```

`source` 命令的另一个用途，是在脚本内部加载外部库

```
#!/bin/bash

source ./lib.sh

function_from_lib

```

上面脚本在内部使用 `source` 命令加载了一个外部库，然后就可以在脚本里面，使用这个外部库定义的函数

`source` 有一个简写形式，可以使用一个点（`.`）来表示

```bash
$ . .bashrc
```

#### 别名，alias 命令

`alias` 命令用来为一个命令指定别名，这样更便于记忆。下面是 `alias` 的格式

```bash
alias NAME=DEFINITION
```

上面命令中，`NAME` 是别名的名称，`DEFINITION` 是别名对应的原始命令

1. 一个常见的例子是为 `grep` 命令起一个 `search` 的别名

```bash
alias search=grep
```

2. 下面是通过别名定义一个 `today` 的命令

```bash
$ alias today='date +"%A, %B %-d, %Y"'
$ today
星期一, 一月 6, 2020
```

3. 有时为了防止误删除文件，可以指定 `rm` 命令的别名

```bash
$ alias rm='rm -i'
```

4. `alias` 定义的别名也可以接受参数，参数会直接传入原始命令

```bash
$ alias echo='echo It says: '
$ echo hello world
It says: hello world
# 别名定义了 echo 命令的前两个参数，等同于修改了 echo 命令的默认行为
```

一般来说，都会把常用的别名写在 `~/.bashrc` 的末尾

另外，只能为命令定义别名，为其他部分（比如很长的路径）定义别名是无效的

直接调用 `alias` 命令，可以显示所有别名


`unalias` 命令可以解除别名
